const observedSlotElement = Symbol('observedSlotElement');
const slotElementObserver = Symbol('slotElementObserver');
const startObserving = Symbol('startObserving');
export function ObserveSlotText(constructor, slotSelector = '#slot') {
    return class SlotTextObservingElement extends constructor {
        constructor() {
            super(...arguments);
            this.slotHasContent = false;
        }
        manageObservedSlot() {
            this[observedSlotElement] = (this[observedSlotElement] ||
                (this.shadowRoot
                    ? this.shadowRoot.querySelector(slotSelector)
                    : undefined));
            if (!this[observedSlotElement]) {
                return;
            }
            const slot = this[observedSlotElement];
            let assignedNodes = slot.assignedNodes
                ? slot.assignedNodes()
                : [...this.childNodes].filter((node) => {
                    const el = node;
                    return !el.hasAttribute('slot');
                });
            assignedNodes = assignedNodes.filter((node) => {
                if (node.tagName) {
                    return true;
                }
                return node.textContent ? node.textContent.trim() : false;
            });
            this.slotHasContent = assignedNodes.length > 0;
            this.requestUpdate();
        }
        firstUpdated(changedProperties) {
            super.firstUpdated(changedProperties);
            this.manageObservedSlot();
        }
        [startObserving]() {
            const config = { characterData: true, subtree: true };
            if (!this[slotElementObserver]) {
                const callback = (mutationsList) => {
                    for (const mutation of mutationsList) {
                        /* istanbul ignore else */
                        if (mutation.type === 'characterData') {
                            this.manageObservedSlot();
                        }
                    }
                };
                this[slotElementObserver] = new MutationObserver(callback);
            }
            this[slotElementObserver].observe(this, config);
        }
        connectedCallback() {
            super.connectedCallback();
            this[startObserving]();
        }
        disconnectedCallback() {
            /* istanbul ignore else */
            if (this[slotElementObserver]) {
                this[slotElementObserver].disconnect();
            }
            super.disconnectedCallback();
        }
    };
}
//# sourceMappingURL=observe-slot-text.js.map